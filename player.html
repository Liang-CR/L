<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>播放器</title>

    <script src="libs/tailwindcss.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        /* Base Styles */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #0f1622;
            color: white;
            font-family: sans-serif; /* Add a default font */
        }

        /* Layout */
        .player-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Player Specific */
        #player {
            width: 100%;
            height: 60vh; /* 视频播放器高度 */
            background-color: #000; /* Add background for player area */
        }

        /* Loading Indicator */
        .loading-container {
            position: absolute;
            inset: 0; /* Use inset shorthand */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            flex-direction: column;
            gap: 10px; /* Add gap between spinner and text */
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            /* margin-bottom: 10px; replaced by gap */
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Error Indicator */
        .error-container {
            position: absolute;
            inset: 0; /* Use inset shorthand */
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            flex-direction: column;
            text-align: center;
            padding: 1rem;
            gap: 10px; /* Add gap */
        }
        .error-icon {
            font-size: 48px;
            /* margin-bottom: 10px; replaced by gap */
        }
        .error-details { /* Style for secondary error text */
            font-size: 14px;
            color: #aaa;
        }

        /* Episode Navigation */
        .episode-grid {
            max-height: 30vh;
            overflow-y: auto;
            padding: 1rem 0;
        }
        .episode-btn { /* Common style for episode buttons */
            /* Defined in renderEpisodes JS for dynamic classes */
            transition: background-color 0.2s ease, border-color 0.2s ease; /* Add transition */
        }
        .episode-active {
            background-color: #3b82f6 !important;
            border-color: #60a5fa !important;
            color: white !important; /* Ensure text color is visible */
        }

        /* Controls: Switch Toggle */
        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
            vertical-align: middle; /* Align better with text */
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            inset: 0; /* Use inset shorthand */
            background-color: #333;
            transition: background-color 0.4s ease; /* Smooth background transition */
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: transform 0.4s ease; /* Smooth sliding transition */
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #00ccff;
        }
        input:checked + .slider:before {
            transform: translateX(22px);
        }

        /* Controls: Buttons */
        .control-button { /* Common style for control buttons */
             padding: 0.5rem 1rem;
             background-color: #222;
             border: 1px solid #333;
             border-radius: 0.5rem;
             transition: background-color 0.2s ease, border-color 0.2s ease;
             display: inline-flex; /* Align icon and text */
             align-items: center;
             gap: 0.5rem; /* Space between icon and text */
             color: white; /* Ensure text color */
        }
        .control-button:hover:not(:disabled) {
            background-color: #333;
        }
        .control-button:disabled {
            background-color: #4a4a4a; /* More distinct disabled style */
            color: #888;
            cursor: not-allowed;
            border-color: #555;
        }
        .control-button svg {
            width: 1.25rem; /* 20px */
            height: 1.25rem; /* 20px */
        }

        /* Shortcut Hint */
        .shortcut-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Prevent interaction */
        }
        .shortcut-hint.show {
            opacity: 1;
        }

        /* Fullscreen Specific */
        /* Keep the original fullscreen styles exactly as they were */
        .player-container:-webkit-full-screen,
        .player-container:fullscreen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 10000;
            background-color: #000;
        }
        .player-container:-webkit-full-screen #player,
        .player-container:fullscreen #player {
            width: 100%; height: 100%;
        }

        /* Password Modal Specific (ensure visibility) */
        #passwordModal {
            /* Original styles are fine, just ensure `hidden` class toggles display */
            transition: opacity 0.3s ease-in-out; /* Added transition */
        }

        /* Toast Notification */
        #custom-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 4px;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Prevent interaction */
            color: white;
        }
        #custom-toast.show {
            opacity: 1;
        }
        #custom-toast.error { background-color: #f44336; }
        #custom-toast.success { background-color: #4caf50; }

        /* Position Restore Hint (if used, needs styles) */
        .position-restore-hint {
            position: absolute;
            bottom: 60px; /* Adjust position relative to controls */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .position-restore-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <header class="bg-[#111] p-4 flex justify-between items-center border-b border-[#333]">
        <div class="flex items-center">
            <a href="index.html" class="flex items-center">
                <svg class="w-8 h-8 mr-2 text-[#00ccff]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
                <h1 class="text-xl font-bold gradient-text">X</h1>
            </a>
        </div>
        <h2 id="videoTitle" class="text-xl font-semibold truncate flex-1 text-center mx-4"></h2> 
        <a href="index.html" class="control-button flex-shrink-0">
            返回首页
        </a>
    </header>

    <!-- Password Modal -->
    <div id="passwordModal" class="fixed inset-0 bg-black/95 hidden items-center justify-center z-[65]">
        <div class="bg-[#111] p-8 rounded-lg w-11/12 max-w-md border border-[#333] max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-6 flex-none">
                <h2 class="text-2xl font-bold gradient-text">访问验证</h2>
        
            </div>
            <div class="mb-6">
                <p class="text-gray-300 mb-4">请输入密码继续访问</p>
                <form id="passwordForm"> 
                    <label for="username" class="sr-only">Username</label> 
                    <input type="text" name="username" id="username" autocomplete="username" style="display:none" tabindex="-1" aria-hidden="true">

                    <label for="passwordInput" class="sr-only">Password</label>
                    <input type="password" id="passwordInput" class="w-full bg-[#111] border border-[#333] text-white px-4 py-3 rounded-lg focus:outline-none focus:border-white transition-colors mb-4" placeholder="密码..." autocomplete="new-password" required> 

                    <button id="passwordSubmitBtn" type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">提交</button> 
                </form>
                <p id="passwordError" class="text-red-500 mt-2 hidden">密码错误，请重试</p>
            </div>
        </div>
    </div>

    <main class="container mx-auto px-4 py-4">
        <!-- Video Player Area -->
        <div id="playerContainer" class="player-container">
            <div class="relative">
                <div id="player"></div>
                <div class="loading-container" id="loading">
                    <div class="loading-spinner"></div>
                    <div id="loadingText">正在加载视频...</div> 
                </div>
                <div class="error-container" id="error">
                    <div class="error-icon">⚠️</div>
                    <div id="errorMessage">视频加载失败</div> 
                    <div id="errorDetails" class="error-details">请尝试其他视频源或稍后重试</div>
                </div>
            </div>
        </div>

        <!-- Episode Navigation Controls -->
        <div class="player-container">
            <div class="flex justify-between items-center my-4">
                <button id="prevButton" class="control-button"> 
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                    <span>上一集</span>
                </button>
                <span class="text-gray-400 mx-2 text-center" id="episodeInfo">加载中...</span>
                <button id="nextButton" class="control-button"> 
                    <span>下一集</span>
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Settings Row -->
        <div class="player-container">
            <div class="flex justify-end items-center mb-4 gap-4"> 
                <label for="autoplayToggle" class="flex items-center gap-2 cursor-pointer">
                    <span class="text-gray-400 text-sm">自动连播</span>
                    <span class="switch">
                        <input type="checkbox" id="autoplayToggle">
                        <span class="slider"></span>
                    </span>
                </label>
                <button id="orderButton" class="ml-4 px-4 py-2 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white font-semibold rounded-full shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center space-x-2"> 
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" id="orderIcon" viewBox="0 0 20 20" fill="currentColor" style="transition: transform 0.3s ease;"> 
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v3.586L7.707 9.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 10.586V7z" clip-rule="evenodd" />
                    </svg>
                    <span id="orderText">倒序排列</span>
                </button>
                 <!--
                 <button id="lockToggle" title="锁定控制" class="px-2 py-1 bg-[#333] hover:bg-[#444] text-white rounded-full transition">
                     <svg id="lockIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z" />
                     </svg>
                 </button>
                 -->
            </div>
        </div>

        <!-- Episode Grid -->
        <div class="player-container">
            <div class="episode-grid" id="episodesGrid">
     
                <div class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2" id="episodesList">
                    <div class="col-span-full text-center text-gray-400 py-8">加载中...</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Shortcut Key Hint -->
    <div class="shortcut-hint" id="shortcutHint">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" id="shortcutIcon">
         
        </svg>
        <span id="shortcutText"></span>
    </div>

    <!-- Toast Notification Placeholder -->
    <div id="custom-toast"></div>

    <!-- External Libraries -->
    <script src="libs/sha256.min.js"></script>
    <script>
        // Preserve original sha256 if needed elsewhere, before password.js potentially overrides it
        window._jsSha256 = window.sha256;
    </script>
    <script src="libs/hls.min.js" crossorigin="anonymous"></script>
    <script src="libs/DPlayer.min.js" crossorigin="anonymous"></script>

    <!-- Configuration and Password Logic -->
    <script src="js/config.js"></script>
    <script src="js/password.js"></script>

    <!-- Main Player Logic -->
    <script>
        // Wrap main logic in an IIFE to avoid polluting global scope
        (function() {
            'use strict'; // Enable strict mode

            // --- Constants ---
            const LS_KEYS = {
                AUTOPLAY: 'autoplayEnabled',
                REVERSED: 'episodesReversed',
                HISTORY: 'viewingHistory',
                AD_FILTERING: window.PLAYER_CONFIG?.adFilteringStorage || 'adFilteringEnabled', // Use config value
                PROGRESS_PREFIX: 'videoProgress_'
            };
            const DOM_IDS = {
                LOADING: 'loading',
                LOADING_TEXT: 'loadingText',
                ERROR: 'error',
                ERROR_MESSAGE: 'errorMessage',
                ERROR_DETAILS: 'errorDetails',
                PLAYER: 'player',
                PLAYER_CONTAINER: 'playerContainer',
                VIDEO_TITLE: 'videoTitle',
                EPISODE_INFO: 'episodeInfo',
                EPISODES_GRID: 'episodesGrid',
                EPISODES_LIST: 'episodesList',
                PREV_BUTTON: 'prevButton',
                NEXT_BUTTON: 'nextButton',
                AUTOPLAY_TOGGLE: 'autoplayToggle',
                ORDER_BUTTON: 'orderButton',
                ORDER_TEXT: 'orderText',
                ORDER_ICON: 'orderIcon',
                SHORTCUT_HINT: 'shortcutHint',
                SHORTCUT_TEXT: 'shortcutText',
                SHORTCUT_ICON: 'shortcutIcon',
                PASSWORD_MODAL: 'passwordModal',
                PASSWORD_FORM: 'passwordForm',
                PASSWORD_INPUT: 'passwordInput',
                PASSWORD_ERROR: 'passwordError',
                TOAST: 'custom-toast'
                // LOCK_TOGGLE: 'lockToggle', // If lock button is re-added
                // LOCK_ICON: 'lockIcon',
            };
            const HLS_DEFAULT_CONFIG = {
                debug: false,
                enableWorker: true,
                lowLatencyMode: false,
                backBufferLength: 90,
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                maxBufferSize: 30 * 1000 * 1000,
                maxBufferHole: 0.5,
                fragLoadingMaxRetry: 6,
                fragLoadingMaxRetryTimeout: 64000,
                fragLoadingRetryDelay: 1000,
                manifestLoadingMaxRetry: 3,
                manifestLoadingRetryDelay: 1000,
                levelLoadingMaxRetry: 4,
                levelLoadingRetryDelay: 1000,
                startLevel: -1, // Auto start level
                abrEwmaDefaultEstimate: 500000,
                abrBandWidthFactor: 0.95,
                abrBandWidthUpFactor: 0.7,
                abrMaxWithRealBitrate: true,
                stretchShortVideoTrack: true,
                appendErrorMaxRetry: 5,
                liveSyncDurationCount: 3,
                liveDurationInfinity: false
            };
            const THROTTLE_INTERVAL = 5000; // ms for progress saving throttle
            const PROGRESS_SAVE_INTERVAL = 30000; // ms for periodic progress saving
            const HISTORY_SAVE_DELAY = 3000; // ms delay before saving to history after load/switch
            const SHORTCUT_HINT_DURATION = 2000; // ms
            const TOAST_DURATION = 3000; // ms

            // --- State Variables ---
            let currentVideoTitle = '未知视频';
            let currentEpisodeIndex = 0;
            let currentEpisodes = [];
            let episodesReversed = false;
            let dp = null; // DPlayer instance
            let currentHls = null; // HLS.js instance
            let autoplayEnabled = true;
            let adFilteringEnabled = true;
            let isUserSeeking = false;
            let videoHasEnded = false;
            let userClickedPosition = null; // Tracks precise seek target
            let shortcutHintTimeout = null;
            let progressSaveIntervalId = null;
            let lastProgressSaveTime = 0;
            let currentSourceCode = ''; // Store source code for API lookup
            let controlsLocked = false; // If lock button is used

            // --- DOM Element References (Cached) ---
            const dom = {}; // Object to store cached elements

            // --- Initialization ---
            document.addEventListener('DOMContentLoaded', main);
            document.addEventListener('passwordVerified', handlePasswordVerified);

            function main() {
                cacheDOMElements(); // Cache elements early
                setupPasswordFormListener(); // Add listener for password form

                if (!isPasswordVerified()) {
                    showPasswordModal();
                    hideLoading(); // Hide loading initially if password needed
                } else {
                    initializePageContent();
                }
            }

            function handlePasswordVerified() {
                hidePasswordModal();
                showLoading(); // Show loading indicator after password verification
                initializePageContent();
            }

            function cacheDOMElements() {
                for (const key in DOM_IDS) {
                    dom[key] = document.getElementById(DOM_IDS[key]);
                    // Basic check if element exists
                    // if (!dom[key]) { console.warn(`DOM Element not found: #${DOM_IDS[key]}`); }
                }
                // Add elements queried by class if needed (e.g., progress bar)
                // dom.progressBar = document.querySelector('.dplayer-bar-wrap');
            }

            function initializePageContent() {
                if (!dom.LOADING) cacheDOMElements(); // Ensure elements are cached if called directly

                const urlParams = new URLSearchParams(window.location.search);
                const videoUrl = urlParams.get('url');
                currentSourceCode = urlParams.get('source_code') || ''; // Store source code

                loadInitialState(urlParams);
                setupEventListeners();

                if (dom.VIDEO_TITLE) dom.VIDEO_TITLE.textContent = currentVideoTitle;
                document.title = `${currentVideoTitle} - 播放器`;

                if (videoUrl) {
                    initPlayer(videoUrl, currentSourceCode);
                    restorePlaybackPosition(urlParams);
                } else {
                    showError('无效的视频链接');
                }

                updateEpisodeInfo();
                renderEpisodes();
                updateButtonStates();
                updateOrderButton();
                window.currentEpisodes = currentEpisodes;
                window.currentEpisodeIndex = currentEpisodeIndex;
                // setupProgressBarPreciseClicks(); // Setup done after player init
            }

            function loadInitialState(urlParams) {
                const title = urlParams.get('title');
                let index = parseInt(urlParams.get('index') || '0', 10); // Always specify radix
                const episodesListParam = urlParams.get('episodes');

                // Load Title
                currentVideoTitle = title || localStorage.getItem('currentVideoTitle') || '未知视频';
                // Fallback: If still '未知视频' and history exists, try loading from history
                if (currentVideoTitle === '未知视频') {
                    const history = getLocalStorageItem(LS_KEYS.HISTORY, []);
                    const potentialMatch = history.find(item => item.url && item.url.includes(`index=${index}`));
                    if (potentialMatch?.title) currentVideoTitle = potentialMatch.title;
                }
                localStorage.setItem('currentVideoTitle', currentVideoTitle); // Ensure it's saved back

                // Load Episodes
                try {
                    if (episodesListParam) {
                        currentEpisodes = JSON.parse(decodeURIComponent(episodesListParam));
                        console.log('从URL恢复集数信息:', currentEpisodes.length);
                    } else {
                        currentEpisodes = getLocalStorageItem('currentEpisodes', []); // Use helper
                        console.log('从localStorage恢复集数信息:', currentEpisodes.length);
                    }
                } catch (e) {
                    console.error('获取集数信息失败:', e);
                    currentEpisodes = [];
                }

                // Validate and set Episode Index
                if (!Array.isArray(currentEpisodes) || currentEpisodes.length === 0) {
                    currentEpisodeIndex = 0;
                    currentEpisodes = [];
                } else {
                     if (isNaN(index) || index < 0 || index >= currentEpisodes.length) {
                        console.warn(`无效的剧集索引 ${index} (总 ${currentEpisodes.length} 集)，调整为有效值`);
                        index = Math.max(0, Math.min(index, currentEpisodes.length - 1)); // Clamp index
                        // Update URL silently if index was adjusted
                        const newUrl = new URL(window.location.href);
                        newUrl.searchParams.set('index', index);
                        window.history.replaceState({}, '', newUrl);
                    }
                    currentEpisodeIndex = index;
                }

                // Load Settings
                autoplayEnabled = getLocalStorageItem(LS_KEYS.AUTOPLAY, 'true') !== 'false';
                adFilteringEnabled = getLocalStorageItem(LS_KEYS.AD_FILTERING, 'true') !== 'false';
                episodesReversed = getLocalStorageItem(LS_KEYS.REVERSED, 'false') === 'true';

                // Update UI for settings
                if (dom.AUTOPLAY_TOGGLE) dom.AUTOPLAY_TOGGLE.checked = autoplayEnabled;
            }

            function restorePlaybackPosition(urlParams) {
                const positionParam = urlParams.get('position');
                const position = parseInt(positionParam || '0', 10);
                if (!isNaN(position) && position > 0) {
                    // Delay slightly to allow player init
                    setTimeout(() => {
                        if (dp && dp.seek) {
                            dp.seek(position);
                            showPositionRestoreHint(position);
                        }
                    }, 1500);
                } else {
                    // If no URL position, try loading from localStorage
                    loadProgressFromStorage();
                }
            }

            function setupEventListeners() {
                // Use event delegation for episodes list
                if (dom.EPISODES_LIST) {
                    dom.EPISODES_LIST.addEventListener('click', handleEpisodeListClick);
                }

                // Buttons
                if (dom.PREV_BUTTON) dom.PREV_BUTTON.addEventListener('click', playPreviousEpisode);
                if (dom.NEXT_BUTTON) dom.NEXT_BUTTON.addEventListener('click', playNextEpisode);
                if (dom.ORDER_BUTTON) dom.ORDER_BUTTON.addEventListener('click', toggleEpisodeOrder);
                // if (dom.LOCK_TOGGLE) dom.LOCK_TOGGLE.addEventListener('click', toggleControlsLock); // If lock button re-added

                // Toggles / Inputs
                if (dom.AUTOPLAY_TOGGLE) dom.AUTOPLAY_TOGGLE.addEventListener('change', handleAutoplayToggle);

                // Keyboard Shortcuts
                document.addEventListener('keydown', handleKeyboardShortcuts);

                // Window Lifecycle
                window.addEventListener('beforeunload', saveCurrentProgress); // Save on leaving
                document.addEventListener('visibilitychange', handleVisibilityChange); // Save on tab hidden

                // Note: Player related event listeners (pause, timeupdate) are added within initPlayer
                // Note: Password form listener is added in main()
            }

            function setupPasswordFormListener() {
                 if (dom.PASSWORD_FORM) {
                    dom.PASSWORD_FORM.addEventListener('submit', (e) => {
                        e.preventDefault(); // Prevent default form submission
                        handlePasswordSubmit(); // Call the original handler (expected from password.js)
                    });
                }
            }

            // --- Player Initialization ---
            function initPlayer(videoUrl, sourceCode) {
                if (!videoUrl || !dom.PLAYER) return;

                // Clean up previous instances if they exist
                destroyPlayer();

                showLoading("正在初始化播放器..."); // Show loading before creating player

                window.filterAdPattern = API_SITES[sourceCode]?.filterAdRule || null;

                const hlsConfig = {
                    ...HLS_DEFAULT_CONFIG, // Spread default config
                    loader: (adFilteringEnabled && window.filterAdPattern) ? CustomHlsJsLoader : Hls.DefaultConfig.loader,
                };

                try {
                    dp = new DPlayer({
                        container: dom.PLAYER,
                        autoplay: true, // DPlayer's autoplay, HLS handles internal play()
                        theme: '#00ccff',
                        preload: 'auto',
                        loop: false,
                        lang: 'zh-cn',
                        hotkey: true,
                        mutex: true,
                        volume: 0.7,
                        screenshot: true,
                        preventClickToggle: false,
                        airplay: true,
                        chromecast: true,
                        // contextmenu: [], // Kept original context menu commented out
                        video: {
                            url: videoUrl,
                            type: 'hls',
                            pic: 'https://img.picgo.net/2025/04/12/image362e7d38b4af4a74.png',
                            customType: {
                                hls: function(video, player) {
                                    // Clean up previous HLS instance specifically
                                    if (currentHls && currentHls.destroy) {
                                        try {
                                            currentHls.destroy();
                                        } catch (e) { console.warn('销毁旧HLS实例出错:', e); }
                                        currentHls = null;
                                    }

                                    const hls = new Hls(hlsConfig);
                                    currentHls = hls; // Store current instance

                                    let errorDisplayed = false;
                                    let hlsErrorCount = 0;
                                    let playbackStarted = false;
                                    let bufferAppendErrorCount = 0;

                                    // --- HLS Event Listeners ---
                                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                                        // Let DPlayer handle play, or play manually if needed
                                        // video.play().catch(e => console.warn('自动播放被阻止:', e));
                                        hideLoading(); // Hide loading once manifest is parsed
                                    });

                                    hls.on(Hls.Events.ERROR, (event, data) => {
                                        console.warn('HLS错误:', event, data); // Log all HLS errors
                                        hlsErrorCount++;

                                        if (data.details === Hls.ErrorDetails.BUFFER_APPEND_ERROR) {
                                            bufferAppendErrorCount++;
                                            console.warn(`bufferAppendError 发生 ${bufferAppendErrorCount} 次`);
                                            if (playbackStarted) return; // Ignore if already playing
                                            if (bufferAppendErrorCount >= 3) {
                                                console.log("尝试恢复媒体错误 (BufferAppend)");
                                                hls.recoverMediaError();
                                                bufferAppendErrorCount = 0; // Reset count after recovery attempt
                                            }
                                        } else if (data.fatal && !playbackStarted) {
                                            console.error('致命HLS错误:', data);
                                            switch(data.type) {
                                                case Hls.ErrorTypes.NETWORK_ERROR:
                                                    console.log("尝试恢复网络错误");
                                                    hls.startLoad(); // Retry loading
                                                    break;
                                                case Hls.ErrorTypes.MEDIA_ERROR:
                                                    console.log("尝试恢复媒体错误");
                                                    hls.recoverMediaError();
                                                    break;
                                                default:
                                                    if (hlsErrorCount > 3 && !errorDisplayed) {
                                                        errorDisplayed = true;
                                                        showError('视频加载失败，源或格式问题');
                                                    }
                                            }
                                        } else if (data.type === Hls.ErrorTypes.NETWORK_ERROR && data.details === Hls.ErrorDetails.FRAG_LOAD_ERROR) {
                                            // Optionally retry fragment load errors more aggressively or inform user
                                            console.warn(`分片加载错误: ${data.frag?.url}`);
                                        }
                                    });

                                    hls.on(Hls.Events.FRAG_LOADED, () => hideLoading());
                                    hls.on(Hls.Events.LEVEL_LOADED, () => hideLoading());

                                    // Attach HLS to video element
                                    hls.loadSource(video.src);
                                    hls.attachMedia(video);

                                    // Airplay support (original implementation retained)
                                    const source = document.createElement('source');
                                    source.src = videoUrl;
                                    video.appendChild(source);
                                    video.disableRemotePlayback = false;

                                    // --- Video Element Listeners (within HLS scope) ---
                                    const onPlaying = () => {
                                        playbackStarted = true;
                                        hideLoading();
                                        hideError();
                                        video.removeEventListener('playing', onPlaying); // Remove listener once played
                                    };
                                    video.addEventListener('playing', onPlaying);

                                    video.addEventListener('timeupdate', () => {
                                        // Hide error if playback progresses past 1s
                                        if (video.currentTime > 1 && dom.ERROR && dom.ERROR.style.display !== 'none') {
                                            hideError();
                                        }
                                    });
                                }
                            }
                        }
                    });

                    // --- DPlayer Event Listeners ---
                    dp.on('loadedmetadata', handleLoadedMetadata);
                    dp.on('error', handleDPlayerError);
                    dp.on('seeking', handleSeeking);
                    dp.on('seeked', handleSeeked);
                    dp.on('ended', handleEnded);
                    dp.on('timeupdate', handleTimeUpdate); // Used for throttled save & potentially preload trigger
                    dp.on('fullscreen', handleFullscreen);
                    dp.on('fullscreen_cancel', handleFullscreenCancel);
                    dp.on('pause', saveCurrentProgress); // Save progress on pause

                    // Setup precise clicks after DPlayer is ready
                    setTimeout(setupProgressBarPreciseClicks, 500); // Delay slightly

                    // Handle long loading scenario
                    const longLoadTimeout = setTimeout(() => {
                        if (dom.LOADING && dom.LOADING.style.display !== 'none' && (!dp || !dp.video || dp.video.currentTime === 0)) {
                            setLoadingText(`视频加载时间较长，请耐心等待...<div class="error-details" style="margin-top: 10px;">如长时间无响应，请尝试其他视频源</div>`);
                        }
                    }, 10000); // 10 seconds
                    // Clear timeout if loadedmetadata fires
                    dp.on('loadedmetadata', () => clearTimeout(longLoadTimeout));


                    // Add native fullscreen binding
                    bindNativeFullscreen();


                } catch (error) {
                    console.error("DPlayer 初始化失败:", error);
                    showError("播放器初始化失败");
                    destroyPlayer(); // Clean up if init failed
                }
            }

             function destroyPlayer() {
                // Stop progress saving interval
                stopProgressSaveInterval();

                // Destroy HLS instance
                if (currentHls && currentHls.destroy) {
                    try {
                        currentHls.destroy();
                    } catch (e) { console.warn("销毁 HLS 实例失败:", e); }
                    currentHls = null;
                }

                // Destroy DPlayer instance
                if (dp && dp.destroy) {
                    try {
                        // Remove listeners added manually to dp.video *before* destroying dp
                        if (dp.video) {
                            dp.video.removeEventListener('pause', saveCurrentProgress);
                            dp.video.removeEventListener('timeupdate', throttledSaveProgress); // Ensure throttled listener is removed if used
                        }
                        dp.destroy();
                    } catch (e) { console.warn("销毁 DPlayer 实例失败:", e); }
                    dp = null;
                }

                // Clear player container content (optional, dp.destroy should handle it)
                // if (dom.PLAYER) dom.PLAYER.innerHTML = '';
            }

            function bindNativeFullscreen() {
                if (!dp || !dom.PLAYER_CONTAINER) return;
                dp.on('fullscreen', () => {
                    if (dom.PLAYER_CONTAINER.requestFullscreen) {
                        dom.PLAYER_CONTAINER.requestFullscreen().catch(err => console.warn('原生全屏请求失败:', err));
                    } else if (dom.PLAYER_CONTAINER.webkitRequestFullscreen) { /* Safari */
                        dom.PLAYER_CONTAINER.webkitRequestFullscreen().catch(err => console.warn('原生全屏请求失败 (webkit):', err));
                    }
                });
                dp.on('fullscreen_cancel', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen().catch(err => console.warn('退出原生全屏失败:', err));
                    } else if (document.webkitFullscreenElement) { /* Safari */
                        document.webkitExitFullscreen().catch(err => console.warn('退出原生全屏失败 (webkit):', err));
                    }
                });
            }

            // --- DPlayer Event Handlers ---
            function handleLoadedMetadata() {
                hideLoading();
                videoHasEnded = false;
                setupProgressBarPreciseClicks(); // Re-setup in case DOM structure changed
                startProgressSaveInterval();
                setTimeout(saveToHistory, HISTORY_SAVE_DELAY); // Delay saving to history
                loadProgressFromStorage(); // Attempt to load progress after metadata loaded
            }

            function handleDPlayerError() {
                // Ignore errors if video is already playing past the first second
                if (dp && dp.video && dp.video.currentTime > 1) {
                    console.log('发生 DPlayer 错误，但视频已在播放中，忽略。');
                    return;
                }
                showError('视频播放失败，请检查源或网络');
            }

            function handleSeeking() {
                isUserSeeking = true;
                videoHasEnded = false;
                if (userClickedPosition !== null && dp && dp.video) {
                    const targetTime = userClickedPosition;
                    // Prevent seeking exactly to the end
                    if (dp.video.duration > 0 && Math.abs(dp.video.duration - targetTime) < 0.5) {
                         dp.video.currentTime = Math.max(0, dp.video.duration - 0.5);
                    } else {
                        dp.video.currentTime = targetTime;
                    }
                    // Clear after a short delay to prevent interference
                    setTimeout(() => { userClickedPosition = null; }, 200);
                }
            }

            function handleSeeked() {
                 // If seek ends very close to the end due to user action, pull back slightly
                if (dp && dp.video && dp.video.duration > 0) {
                    const timeFromEnd = dp.video.duration - dp.video.currentTime;
                    if (isUserSeeking && timeFromEnd < 0.3) {
                        dp.video.currentTime = Math.max(0, dp.video.currentTime - 1);
                    }
                }
                 // Delay resetting the seeking flag
                setTimeout(() => { isUserSeeking = false; }, 200);
            }

            function handleEnded() {
                console.log("视频播放结束事件触发");
                // Double check if it was a natural end vs. near-end seek
                 if (isUserSeeking || (dp && dp.video && dp.video.duration > 0 && (dp.video.duration - dp.video.currentTime > 1))) {
                    console.log("检测到结束事件，但可能由seek触发或未真正结束，忽略自动播放");
                    videoHasEnded = false; // Ensure flag is false if not a true end
                    return;
                }

                videoHasEnded = true;
                clearVideoProgress(); // Clear stored progress for this specific video
                stopProgressSaveInterval(); // Stop saving progress

                if (autoplayEnabled && currentEpisodeIndex < currentEpisodes.length - 1) {
                    console.log('视频自然播放结束，准备自动播放下一集');
                    // Use a slightly longer delay to ensure stability
                    setTimeout(() => {
                         // Final check before playing next
                         if (videoHasEnded && !isUserSeeking && autoplayEnabled) {
                            playNextEpisode();
                         } else {
                             console.log("自动播放条件不再满足，取消播放下一集");
                         }
                    }, 1200); // Increased delay
                } else {
                    console.log('视频播放结束，无下一集或自动连播未开启');
                }
            }

            // Throttled progress saving on timeupdate
            const throttledSaveProgress = throttle(saveCurrentProgress, THROTTLE_INTERVAL);

            function handleTimeUpdate() {
                // Trigger throttled progress save
                throttledSaveProgress();

                // Reset ended flag if user seeks away from the end
                if (dp && dp.video && dp.video.duration > 0) {
                     if (isUserSeeking && dp.video.currentTime < dp.video.duration - 1) {
                         videoHasEnded = false;
                     }
                 }
                 // Preload trigger logic is handled by the separate preload script
            }

            function handleFullscreen() {
                lockScreenOrientation('landscape');
            }

            function handleFullscreenCancel() {
                unlockScreenOrientation();
            }

            function handleVisibilityChange() {
                if (document.visibilityState === 'hidden') {
                    saveCurrentProgress(); // Save progress when tab is hidden
                }
            }

            // --- UI Update Functions ---
            function updateEpisodeInfo() {
                if (!dom.EPISODE_INFO) return;
                if (currentEpisodes.length > 0) {
                    dom.EPISODE_INFO.textContent = `第 ${currentEpisodeIndex + 1} / ${currentEpisodes.length} 集`;
                } else {
                    dom.EPISODE_INFO.textContent = '无集数信息';
                }
            }

            function updateButtonStates() {
                if (dom.PREV_BUTTON) {
                    dom.PREV_BUTTON.disabled = currentEpisodeIndex <= 0;
                }
                if (dom.NEXT_BUTTON) {
                    dom.NEXT_BUTTON.disabled = currentEpisodeIndex >= currentEpisodes.length - 1;
                }
            }

            function renderEpisodes() {
                if (!dom.EPISODES_LIST) return;

                if (!currentEpisodes || currentEpisodes.length === 0) {
                    dom.EPISODES_LIST.innerHTML = '<div class="col-span-full text-center text-gray-400 py-8">没有可用的集数</div>';
                    return;
                }

                const displayEpisodes = episodesReversed ? [...currentEpisodes].reverse() : currentEpisodes;
                const fragment = document.createDocumentFragment(); // Use fragment for performance

                displayEpisodes.forEach((episodeUrl, displayIndex) => {
                    const realIndex = episodesReversed ? currentEpisodes.length - 1 - displayIndex : displayIndex;
                    const isActive = realIndex === currentEpisodeIndex;

                    const button = document.createElement('button');
                    button.dataset.index = realIndex; // Store index in data attribute
                    button.id = `episode-${realIndex}`; // Keep original ID format
                    button.textContent = `第 ${realIndex + 1} 集`;
                    button.className = `episode-btn px-4 py-2 border rounded-lg text-center transition-colors ${
                        isActive
                            ? 'episode-active bg-[#3b82f6] border-blue-500'
                            : 'bg-[#222] hover:bg-[#333] border-[#333]'
                    }`;
                    // Set ARIA attributes for accessibility
                    button.setAttribute('role', 'button');
                    if (isActive) {
                        button.setAttribute('aria-current', 'true');
                    }

                    fragment.appendChild(button);
                });

                dom.EPISODES_LIST.innerHTML = ''; // Clear existing buttons
                dom.EPISODES_LIST.appendChild(fragment); // Append new buttons
            }

            function updateOrderButton() {
                if (dom.ORDER_TEXT && dom.ORDER_ICON) {
                    dom.ORDER_TEXT.textContent = episodesReversed ? '正序排列' : '倒序排列';
                    dom.ORDER_ICON.style.transform = episodesReversed ? 'rotate(180deg)' : 'rotate(0deg)';
                }
            }

            function showLoading(message = "正在加载视频...") {
                if (!dom.LOADING) return;
                setLoadingText(message);
                dom.LOADING.style.display = 'flex';
                 hideError(); // Ensure error is hidden when loading shows
            }

            function hideLoading() {
                if (dom.LOADING) dom.LOADING.style.display = 'none';
            }

             function setLoadingText(htmlContent) {
                if (dom.LOADING_TEXT) dom.LOADING_TEXT.innerHTML = htmlContent; // Use innerHTML for potential HTML in message
            }

            function showError(message, details = "请尝试其他视频源或稍后重试") {
                // Avoid showing error if video is already playing
                if (dp && dp.video && dp.video.currentTime > 1 && !message.includes("初始化")) {
                    console.log('播放中忽略错误:', message);
                    return;
                }
                if (!dom.ERROR) return;
                if (dom.ERROR_MESSAGE) dom.ERROR_MESSAGE.textContent = message;
                if (dom.ERROR_DETAILS) dom.ERROR_DETAILS.textContent = details;
                dom.ERROR.style.display = 'flex';
                hideLoading(); // Ensure loading is hidden when error shows
            }

            function hideError() {
                if (dom.ERROR) dom.ERROR.style.display = 'none';
            }

            function showPasswordModal() {
                 if (dom.PASSWORD_MODAL) {
                    dom.PASSWORD_MODAL.classList.remove('hidden');
                    dom.PASSWORD_MODAL.classList.add('flex'); // Use flex to display
                    // Optionally focus the input
                    if(dom.PASSWORD_INPUT) dom.PASSWORD_INPUT.focus();
                 }
            }

            function hidePasswordModal() {
                if (dom.PASSWORD_MODAL) {
                    dom.PASSWORD_MODAL.classList.add('hidden');
                    dom.PASSWORD_MODAL.classList.remove('flex');
                }
                 if (dom.PASSWORD_ERROR) dom.PASSWORD_ERROR.classList.add('hidden'); // Hide error on close
                 if (dom.PASSWORD_INPUT) dom.PASSWORD_INPUT.value = ''; // Clear password input
            }

             function showToast(message, type = 'error', duration = TOAST_DURATION) {
                if (!dom.TOAST) return;
                dom.TOAST.textContent = message;
                dom.TOAST.className = type; // 'error' or 'success'
                dom.TOAST.classList.add('show');

                // Clear previous timeout if any
                if (dom.TOAST._timeoutId) {
                    clearTimeout(dom.TOAST._timeoutId);
                }

                dom.TOAST._timeoutId = setTimeout(() => {
                    dom.TOAST.classList.remove('show');
                    dom.TOAST._timeoutId = null;
                }, duration);
            }

            // --- Playback Control ---
            function playEpisode(index) {
                if (isNaN(index) || index < 0 || index >= currentEpisodes.length) {
                    console.error(`无效的剧集索引: ${index}, 总数: ${currentEpisodes.length}`);
                    showToast(`无效的剧集索引: ${index + 1}`);
                    return;
                }

                // Save progress before switching
                saveCurrentProgress();
                stopProgressSaveInterval(); // Stop interval before switching

                showLoading(`正在加载第 ${index + 1} 集...`);
                hideError();

                const newUrl = currentEpisodes[index];
                currentEpisodeIndex = index;
                videoHasEnded = false;
                userClickedPosition = null;

                // Update Browser URL history
                const urlParams = new URLSearchParams(window.location.search);
                const sourceName = urlParams.get('source') || '';
                 // currentSourceCode is already stored

                const historyUrl = new URL(window.location.href);
                historyUrl.searchParams.set('index', index);
                historyUrl.searchParams.set('url', newUrl); // Update URL param
                if (sourceName) historyUrl.searchParams.set('source', sourceName);
                if (currentSourceCode) historyUrl.searchParams.set('source_code', currentSourceCode);
                 // Remove position param when switching episodes
                historyUrl.searchParams.delete('position');
                window.history.pushState({ path: historyUrl.toString() }, '', historyUrl); // Use pushState

                // Update Player
                if (dp) {
                    try {
                        // Set ad pattern based on current source code BEFORE switching
                        window.filterAdPattern = API_SITES[currentSourceCode]?.filterAdRule || null;

                        dp.switchVideo({ url: newUrl, type: 'hls' });

                        // DPlayer usually autoplays after switch, but ensure it tries
                        const playPromise = dp.play();
                        if (playPromise && typeof playPromise.catch === 'function') {
                            playPromise.catch(error => {
                                console.warn('切换后播放失败:', error);
                                // Maybe attempt re-init as fallback, but switchVideo should handle it
                                // initPlayer(newUrl, currentSourceCode);
                            });
                        }
                    } catch (e) {
                        console.error('切换视频出错，尝试重新初始化:', e);
                        // Fallback: destroy and re-initialize
                         destroyPlayer();
                        initPlayer(newUrl, currentSourceCode);
                    }
                } else {
                    // If dp doesn't exist, initialize it
                    initPlayer(newUrl, currentSourceCode);
                }

                // Update UI
                updateEpisodeInfo();
                updateButtonStates();
                renderEpisodes(); // Re-render to update active state

                // Trigger preload for the *next* episode after this one loads
                // Preload logic is handled in the separate IIFE, triggered by playEpisode wrapper
            }

            function playPreviousEpisode() {
                if (currentEpisodeIndex > 0) {
                    playEpisode(currentEpisodeIndex - 1);
                }
            }

            function playNextEpisode() {
                if (currentEpisodeIndex < currentEpisodes.length - 1) {
                    playEpisode(currentEpisodeIndex + 1);
                }
            }

            // --- Settings & UI Interaction ---
             function handleEpisodeListClick(event) {
                const targetButton = event.target.closest('button.episode-btn');
                if (targetButton && targetButton.dataset.index !== undefined) {
                    const indexToPlay = parseInt(targetButton.dataset.index, 10);
                    if (!isNaN(indexToPlay)) {
                        playEpisode(indexToPlay);
                    }
                }
            }

            function handleAutoplayToggle(event) {
                autoplayEnabled = event.target.checked;
                setLocalStorageItem(LS_KEYS.AUTOPLAY, autoplayEnabled);
            }

            function toggleEpisodeOrder() {
                episodesReversed = !episodesReversed;
                setLocalStorageItem(LS_KEYS.REVERSED, episodesReversed);
                renderEpisodes();
                updateOrderButton();
            }

             // Lock functionality (keep original logic if re-added)
             function toggleControlsLock() {
                 // controlsLocked = !controlsLocked;
                 // if (dom.PLAYER_CONTAINER) dom.PLAYER_CONTAINER.classList.toggle('controls-locked', controlsLocked);
                 // if (dom.LOCK_ICON) {
                 //     dom.LOCK_ICON.innerHTML = controlsLocked
                 //         ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m0-8V7a4 4 0 00-8 0v2m8 0H4v8h16v-8h-4z"/>' // Locked Icon
                 //         : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z"/>'; // Unlocked Icon
                 // }
                 // if (dom.LOCK_TOGGLE) dom.LOCK_TOGGLE.title = controlsLocked ? "解锁控制" : "锁定控制";
             }

            function handleKeyboardShortcuts(e) {
                // Ignore if typing in an input field or modal is open
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || (dom.PASSWORD_MODAL && !dom.PASSWORD_MODAL.classList.contains('hidden'))) {
                    return;
                }

                let shortcutUsed = false;
                if (e.altKey) {
                    if (e.key === 'ArrowLeft' && currentEpisodeIndex > 0) {
                        playPreviousEpisode();
                        showShortcutHint('上一集', 'left');
                        shortcutUsed = true;
                    } else if (e.key === 'ArrowRight' && currentEpisodeIndex < currentEpisodes.length - 1) {
                        playNextEpisode();
                        showShortcutHint('下一集', 'right');
                        shortcutUsed = true;
                    }
                }

                if (shortcutUsed) {
                    e.preventDefault(); // Prevent default browser action (e.g., history navigation)
                } else {
                    // Let DPlayer handle its own hotkeys (space, arrows for seek/volume) if no custom shortcut matched
                }
            }

            function showShortcutHint(text, direction) {
                if (!dom.SHORTCUT_HINT || !dom.SHORTCUT_TEXT || !dom.SHORTCUT_ICON) return;

                clearTimeout(shortcutHintTimeout); // Clear previous timeout

                dom.SHORTCUT_TEXT.textContent = text;
                // Set SVG path based on direction
                dom.SHORTCUT_ICON.innerHTML = direction === 'left'
                    ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>'
                    : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>';

                dom.SHORTCUT_HINT.classList.add('show');

                shortcutHintTimeout = setTimeout(() => {
                    dom.SHORTCUT_HINT.classList.remove('show');
                }, SHORTCUT_HINT_DURATION);
            }

            function setupProgressBarPreciseClicks() {
                 // Query the element dynamically as DPlayer might recreate it
                const progressBarWrap = dom.PLAYER?.querySelector('.dplayer-bar-wrap');
                if (!progressBarWrap || !dp || !dp.video) {
                    // console.warn("Progress bar element not found for precise click setup.");
                    // Retry after a delay if player might still be initializing
                    // setTimeout(setupProgressBarPreciseClicks, 500);
                    return;
                }

                // Remove potentially existing listeners to avoid duplicates
                progressBarWrap.removeEventListener('mousedown', handleProgressBarInteraction);
                progressBarWrap.removeEventListener('touchstart', handleProgressBarInteraction, { passive: true }); // Use passive for touch

                // Add new listeners
                progressBarWrap.addEventListener('mousedown', handleProgressBarInteraction);
                progressBarWrap.addEventListener('touchstart', handleProgressBarInteraction, { passive: true });
                 // console.log("进度条精确点击/触摸监听器已设置");
            }

             function handleProgressBarInteraction(e) {
                if (!dp || !dp.video || dp.video.duration <= 0) return;

                let clientX;
                if (e.type === 'touchstart') {
                    if (!e.touches[0]) return;
                    clientX = e.touches[0].clientX;
                } else {
                    clientX = e.clientX;
                }

                const rect = e.currentTarget.getBoundingClientRect();
                const percentage = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width)); // Clamp between 0 and 1
                const duration = dp.video.duration;
                let targetTime = percentage * duration;

                // Adjust if click is very near the end to prevent accidental 'ended' event
                 if (duration - targetTime < 1.0) {
                    targetTime = Math.max(0, duration - 1.5); // Seek 1.5s before the end
                    console.log(`进度条交互接近结尾，调整时间为 ${targetTime.toFixed(2)}`);
                 }

                userClickedPosition = targetTime; // Store the calculated target time
                isUserSeeking = true; // Set seeking flag immediately
                videoHasEnded = false; // Interaction resets ended flag

                console.log(`进度条交互: ${e.type}, 百分比: ${percentage.toFixed(4)}, 目标时间: ${targetTime.toFixed(2)}/${duration.toFixed(2)}`);

                // Prevent DPlayer's default handling which might not be as precise near the end
                e.stopPropagation();

                // Seek directly
                dp.seek(targetTime);

                 // If it was a touchstart, we might want to prevent default scroll/zoom
                 if (e.type === 'touchstart') {
                     // e.preventDefault(); // Be cautious with this, might break scrolling on the page
                 }
            }

            // --- History & Progress Persistence ---
            function saveToHistory() {
                 if (!currentEpisodes || typeof currentEpisodeIndex !== 'number') {
                     console.warn('无法保存历史记录: 集数或索引信息不完整');
                     return;
                 }

                const urlParams = new URLSearchParams(window.location.search);
                const sourceName = urlParams.get('source') || '';
                // currentSourceCode is already stored

                let currentPosition = 0;
                let videoDuration = 0;
                if (dp && dp.video) {
                    currentPosition = dp.video.currentTime;
                    videoDuration = dp.video.duration || 0; // Ensure duration is number
                }

                // Only save meaningful progress (e.g., played more than 10s or >5% )
                const progressThreshold = Math.max(10, videoDuration * 0.05);
                 if (currentPosition < progressThreshold && videoDuration > 0) {
                    currentPosition = 0; // Reset position if not played significantly
                 }


                const videoInfo = {
                    title: currentVideoTitle,
                    // Use a base URL + params for easier identification, but store full URL too
                    // base_url: `player.html?title=${encodeURIComponent(currentVideoTitle)}&source=${encodeURIComponent(sourceName)}&source_code=${encodeURIComponent(currentSourceCode)}`,
                    url: window.location.href, // Store the exact current URL for easy resume
                    episodeIndex: currentEpisodeIndex,
                    sourceName: sourceName,
                    sourceCode: currentSourceCode, // Save source code too
                    timestamp: Date.now(),
                    playbackPosition: currentPosition,
                    duration: videoDuration,
                    // Ensure episodes is always an array, perform deep copy
                    episodes: Array.isArray(currentEpisodes) ? [...currentEpisodes] : []
                };

                // Prefer external function if available (from index.html context)
                 if (typeof window.addToViewingHistory === 'function') {
                     window.addToViewingHistory(videoInfo);
                     console.log(`已调用外部 addToViewingHistory: "${currentVideoTitle}"`);
                 } else {
                    // Fallback to localStorage implementation
                    try {
                        const history = getLocalStorageItem(LS_KEYS.HISTORY, []);

                        // Find existing entry based on title AND sourceCode for uniqueness
                        const existingIndex = history.findIndex(item =>
                            item.title === videoInfo.title && item.sourceCode === videoInfo.sourceCode
                        );

                        if (existingIndex !== -1) {
                            // Update existing entry
                            const existingItem = history[existingIndex];
                            existingItem.episodeIndex = videoInfo.episodeIndex;
                            existingItem.timestamp = videoInfo.timestamp;
                            existingItem.sourceName = videoInfo.sourceName; // Update source name too
                            existingItem.url = videoInfo.url; // Update resume URL
                            existingItem.playbackPosition = videoInfo.playbackPosition;
                            existingItem.duration = videoInfo.duration;
                            // Update episodes only if necessary (e.g., length changed)
                            if (!existingItem.episodes || existingItem.episodes.length !== videoInfo.episodes.length) {
                                existingItem.episodes = videoInfo.episodes;
                                console.log(`更新 "${videoInfo.title}" 的剧集数据: ${videoInfo.episodes.length}集`);
                            }

                            // Move updated item to the top
                            history.splice(existingIndex, 1);
                            history.unshift(existingItem);
                            console.log(`已更新历史记录: "${videoInfo.title}"`);
                        } else {
                            // Add as new entry
                            history.unshift(videoInfo);
                             // Limit history size
                             const MAX_HISTORY_ITEMS = 50;
                             if (history.length > MAX_HISTORY_ITEMS) {
                                 history.splice(MAX_HISTORY_ITEMS);
                             }
                            console.log(`已添加新历史记录: "${videoInfo.title}"`);
                        }

                        setLocalStorageItem(LS_KEYS.HISTORY, history);
                    } catch (e) {
                        console.error('保存观看历史到 localStorage 失败:', e);
                    }
                }
            }

             function getVideoProgressKey() {
                // Generate a unique key for progress storage based on title, source, and episode index
                // Encoding components prevents issues with special characters
                return `${LS_KEYS.PROGRESS_PREFIX}${encodeURIComponent(currentVideoTitle)}_${encodeURIComponent(currentSourceCode)}_${currentEpisodeIndex}`;
            }

            function saveCurrentProgress() {
                if (!dp || !dp.video || videoHasEnded) return; // Don't save if video ended

                const currentTime = dp.video.currentTime;
                const duration = dp.video.duration;

                // Don't save if duration is unknown, or time is near 0 or end (unless duration is short)
                if (!duration || duration <= 0 || currentTime < 1 || (duration - currentTime < 5 && duration > 30)) {
                     // console.log("Skipping progress save (invalid time/duration or near end)");
                    return;
                }

                const progressKey = getVideoProgressKey();
                const progressData = {
                    position: currentTime,
                    duration: duration,
                    timestamp: Date.now()
                };

                try {
                    setLocalStorageItem(progressKey, progressData);
                     // console.log(`进度已保存: ${currentTime.toFixed(1)}s at ${new Date().toLocaleTimeString()}`);

                     // Also update the main history record's position (optional, but keeps it fresh)
                     // This part might be redundant if history is saved frequently anyway
                     // updateHistoryWithProgress(currentTime, duration);

                } catch (e) {
                    console.error('保存播放进度失败:', e);
                }
            }

             function loadProgressFromStorage() {
                if (!dp || !dp.seek) return;

                const progressKey = getVideoProgressKey();
                const progressData = getLocalStorageItem(progressKey, null);

                if (progressData && progressData.position && progressData.duration) {
                    const savedPosition = Number(progressData.position);
                    const savedDuration = Number(progressData.duration);
                     // Check if saved data is recent enough (e.g., within a week) and position is meaningful
                    const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
                     if (progressData.timestamp > oneWeekAgo && savedPosition > 5 && savedDuration > 30 && Math.abs(savedDuration - (dp.video.duration || 0)) < 10) { // Check duration match roughly
                         // Only seek if current time is near 0 (avoid overriding user actions)
                        if (dp.video.currentTime < 2) {
                            console.log(`从 localStorage 恢复播放位置: ${savedPosition.toFixed(1)}s`);
                            dp.seek(savedPosition);
                            showPositionRestoreHint(savedPosition);
                        } else {
                             console.log(`找到 localStorage 进度 ${savedPosition.toFixed(1)}s，但当前播放已开始，不自动跳转。`);
                         }
                     } else {
                        // Stale or invalid progress data, remove it
                        console.log("发现无效或过期的进度数据，已忽略。 Key:", progressKey);
                        // localStorage.removeItem(progressKey); // Optionally remove old data
                     }
                 }
             }

            function clearVideoProgress() {
                const progressKey = getVideoProgressKey();
                try {
                    localStorage.removeItem(progressKey);
                    console.log('当前视频播放进度已清除');
                } catch (e) {
                    console.error('清除播放进度记录失败:', e);
                }
            }

            function startProgressSaveInterval() {
                stopProgressSaveInterval(); // Ensure no duplicates
                progressSaveIntervalId = setInterval(saveCurrentProgress, PROGRESS_SAVE_INTERVAL);
                console.log("启动进度定时保存 (间隔30秒)");
            }

            function stopProgressSaveInterval() {
                if (progressSaveIntervalId) {
                    clearInterval(progressSaveIntervalId);
                    progressSaveIntervalId = null;
                     console.log("停止进度定时保存");
                }
            }

            // --- Utility Functions ---
             function getLocalStorageItem(key, defaultValue) {
                try {
                    const item = localStorage.getItem(key);
                    return item === null ? defaultValue : JSON.parse(item);
                } catch (e) {
                    console.error(`读取 localStorage 失败 (Key: ${key}):`, e);
                    return defaultValue;
                }
            }

            function setLocalStorageItem(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                } catch (e) {
                    console.error(`写入 localStorage 失败 (Key: ${key}):`, e);
                     // Handle potential quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        showToast('存储空间不足，无法保存设置或进度');
                        // Consider implementing a cleanup strategy for old data here
                    }
                }
            }

            function formatTime(seconds) {
                if (isNaN(seconds) || seconds < 0) return '00:00';
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            }

             function showPositionRestoreHint(position) {
                // Reuse the toast mechanism for simplicity or create a dedicated element
                // showToast(`已从 ${formatTime(position)} 继续播放`, 'success', 4000);

                 // Or use the dedicated hint element style from CSS
                 const hintContainer = dom.PLAYER_CONTAINER; // Place hint within player area
                 if (!hintContainer) return;

                 let hintElement = hintContainer.querySelector('.position-restore-hint');
                 if (!hintElement) {
                     hintElement = document.createElement('div');
                     hintElement.className = 'position-restore-hint';
                     hintContainer.appendChild(hintElement);
                 }

                 hintElement.textContent = `已从 ${formatTime(position)} 继续播放`;
                 hintElement.classList.add('show');

                 // Clear previous timeout if any
                 if (hintElement._timeoutId) {
                     clearTimeout(hintElement._timeoutId);
                 }

                 hintElement._timeoutId = setTimeout(() => {
                     hintElement.classList.remove('show');
                     hintElement._timeoutId = null;
                 }, 4000); // Show for 4 seconds
             }

            // Throttle function: Executes func at most once per wait milliseconds
            function throttle(func, wait) {
                let context, args, result;
                let timeout = null;
                let previous = 0;
                let later = function() {
                    previous = Date.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                };
                return function() {
                    let now = Date.now();
                    if (!previous) previous = now;
                    let remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0 || remaining > wait) {
                        if (timeout) {
                            clearTimeout(timeout);
                            timeout = null;
                        }
                        previous = now;
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            }

             // Screen Orientation Lock (Best effort)
            async function lockScreenOrientation(orientation) {
                try {
                    if (screen.orientation && screen.orientation.lock) {
                        await screen.orientation.lock(orientation);
                        console.log(`屏幕方向已尝试锁定为: ${orientation}`);
                    } else {
                        console.warn('浏览器不支持 screen.orientation.lock API');
                    }
                } catch (error) {
                    console.warn(`锁定屏幕方向 (${orientation}) 失败:`, error);
                }
            }

            function unlockScreenOrientation() {
                try {
                    if (screen.orientation && screen.orientation.unlock) {
                        screen.orientation.unlock();
                        console.log('屏幕方向已解锁');
                    }
                } catch (error) {
                    console.warn('解锁屏幕方向失败:', error);
                }
            }

            // --- Ad Filtering Loader ---
            // Define the class within the IIFE scope
             class CustomHlsJsLoader extends Hls.DefaultConfig.loader {
                constructor(config) {
                    super(config);
                    const originalLoad = this.load.bind(this); // Bind original load correctly
                    this.load = function(context, config, callbacks) {
                        if ((context.type === Hls.LoaderContextType.MANIFEST || context.type === Hls.LoaderContextType.LEVEL) && context.url) {
                             const originalOnSuccess = callbacks.onSuccess;
                             callbacks.onSuccess = function(response, stats, context) {
                                if (response.data && typeof response.data === 'string') {
                                    // Check if filter pattern exists *before* filtering
                                    if (window.filterAdPattern) {
                                         try {
                                             const originalLength = response.data.length;
                                             response.data = filterAdsFromM3U8(response.data);
                                             if (response.data.length < originalLength) {
                                                  console.log(`M3U8 广告过滤已应用到: ${context.url}`);
                                             }
                                         } catch (filterError) {
                                             console.error("M3U8 过滤时出错:", filterError);
                                             // Proceed with original data if filtering fails
                                         }
                                     }
                                 }
                                return originalOnSuccess(response, stats, context); // Call original success callback
                            };
                        }
                        // Execute the original load method
                        originalLoad(context, config, callbacks);
                    };
                }
            }

            function filterAdsFromM3U8(m3u8Content) {
                if (!m3u8Content || !window.filterAdPattern) {
                    return m3u8Content;
                }
                 // Use the globally defined pattern
                try {
                    const regex = new RegExp(window.filterAdPattern, 'g');
                    return m3u8Content.replace(regex, '');
                } catch (e) {
                     console.error("广告过滤正则表达式无效:", e, " Pattern:", window.filterAdPattern);
                     return m3u8Content; // Return original content if regex fails
                 }
            }

            // --- Password Related (Ensure functions are available if called from password.js) ---
            // Expose necessary functions/variables to global scope if password.js needs them
            // Example: window.showError = showError; (Use this sparingly)
            // Note: Assuming password.js dispatches the 'passwordVerified' event correctly.


            // Make `playEpisode` globally accessible for the preload script wrapper
             window.playEpisodeInternal = playEpisode;


        })(); // End of IIFE

        // Keep preload script separate but ensure it calls the internal playEpisode
        // Also update preload script to use constants/helpers if applicable
    </script>

    <script>
    /**
     * 集数预加载功能 (Optimized Version)
     * Dependencies: PLAYER_CONFIG, window.playEpisodeInternal
     */
    (function(){
        'use strict';

        // --- Constants (Consider sharing from main script if possible/cleaner) ---
        const PRELOAD_CONFIG_DEFAULTS = {
            preloadCount: 2,
            enablePreloading: true,
            debugMode: false,
            cacheName: 'libretv-preload1',
            tsSegmentLimit: 3, // Max TS segments to preload per episode
            preloadDelay: 250, // ms delay after actions
            initialPreloadDelay: 150, // ms delay for first preload check
            maxInitialRetries: 10,
            networkCheckEnabled: true,
            timeUpdateThreshold: 12 // seconds from end to trigger preload
        };

        // --- Getters for configuration (Ensures defaults are used) ---
        function getConfigValue(key) {
            return (window.PLAYER_CONFIG && typeof window.PLAYER_CONFIG[key] !== 'undefined')
                ? window.PLAYER_CONFIG[key]
                : PRELOAD_CONFIG_DEFAULTS[key];
        }
        const isDebug = () => getConfigValue('debugMode');
        const getPreloadCount = () => getConfigValue('preloadCount');
        const isPreloadingEnabled = () => getConfigValue('enablePreloading');
        const getCacheName = () => getConfigValue('cacheName');
        const getTsLimit = () => getConfigValue('tsSegmentLimit');

        // --- State ---
        // No persistent state needed here, relies on main script's state

        // --- Utilities ---
        function supportsCacheStorage() {
            return 'caches' in window && typeof window.caches.open === 'function';
        }

        function isSlowNetwork() {
            if (!getConfigValue('networkCheckEnabled')) return false;
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                return conn && conn.effectiveType && /^(?:slow-)?2g$/i.test(conn.effectiveType);
            } catch {
                return false; // Assume not slow if API fails
            }
        }

        // Log helper respects debugMode
        function log(...args) {
            if (isDebug()) {
                console.log('[Preload]', ...args);
            }
        }
        function logWarn(...args) {
            if (isDebug()) {
                console.warn('[Preload]', ...args);
            }
        }
        function logError(...args) {
            // Always log errors? Or respect debugMode? Let's respect it for consistency.
            if (isDebug()) {
                console.error('[Preload]', ...args);
            }
        }

        // --- Core Preload Logic ---
        async function preloadNextEpisodeParts() {
            if (!isPreloadingEnabled()) return;
            if (isSlowNetwork()) {
                log('跳过，网络连接慢');
                return;
            }

            // Access state safely from main script (assuming IIFE structure)
             // Use window scope directly as main script modifies it
            const episodes = window.currentEpisodes;
            const currentIndex = window.currentEpisodeIndex;
            const preloadCount = getPreloadCount();


            if (!Array.isArray(episodes) || episodes.length === 0 || typeof currentIndex !== 'number') {
                logWarn('跳过，集数或当前索引无效');
                return;
            }

            const maxIndex = episodes.length - 1;
            log(`开始预加载 第 ${currentIndex + 2} 到 ${Math.min(currentIndex + 1 + preloadCount, maxIndex + 1)} 集`);

            for (let offset = 1; offset <= preloadCount; offset++) {
                const episodeIdx = currentIndex + offset;
                if (episodeIdx > maxIndex) break; // Stop if index exceeds available episodes

                const nextUrl = episodes[episodeIdx];
                if (!nextUrl || typeof nextUrl !== 'string') {
                    logWarn(`略过无效 URL @ 索引 ${episodeIdx}`);
                    continue;
                }

                 // Avoid preloading the same M3U8 repeatedly in quick succession if needed (simple check)
                 // Could implement a more robust check if hammering is an issue
                // if (recentlyPreloaded.has(nextUrl)) continue;
                // recentlyPreloaded.add(nextUrl); setTimeout(()=> recentlyPreloaded.delete(nextUrl), 60000);

                await processEpisodePreload(nextUrl, episodeIdx);
            }
        }

        async function processEpisodePreload(m3u8Url, episodeIndex) {
            log(`处理预加载: 第 ${episodeIndex + 1} 集 @ ${m3u8Url}`);
            try {
                // Fetch M3U8 Manifest
                const m3u8Response = await fetch(m3u8Url, { method: "GET", mode: 'cors' }); // Ensure CORS
                if (!m3u8Response.ok) {
                    logWarn(`M3U8 请求失败 (${m3u8Response.status}): ${m3u8Url}`);
                    return; // Skip this episode on manifest fetch failure
                }
                const m3u8Text = await m3u8Response.text();

                // Parse TS URLs from Manifest
                const tsUrls = parseTsUrlsFromM3U8(m3u8Text, m3u8Url, getTsLimit());
                log(`解析到 ${tsUrls.length} 个 TS 分片用于预加载 (限制 ${getTsLimit()})`);

                // Preload TS Segments (using Cache API if available)
                if (supportsCacheStorage()) {
                    await preloadTsSegmentsWithCache(tsUrls);
                } else {
                    await preloadTsSegmentsWithoutCache(tsUrls);
                }

            } catch (error) {
                logError(`预加载 第 ${episodeIndex + 1} 集时发生异常: ${m3u8Url}`, error);
            }
        }

         function parseTsUrlsFromM3U8(m3u8Text, baseUrl, limit) {
            const urls = [];
            const lines = m3u8Text.split('\n');
            const base = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);

            for (const line of lines) {
                const trimmedLine = line.trim();
                 // Basic check: not empty, not a comment, looks like a TS segment URL
                if (trimmedLine && !trimmedLine.startsWith("#") && /(\.ts|\.aac|\.mp4)(\?|$)/i.test(trimmedLine)) {
                     try {
                         // Handle absolute and relative URLs
                        const tsUrl = new URL(trimmedLine, base).toString();
                        urls.push(tsUrl);
                        if (urls.length >= limit) break; // Stop once limit is reached
                     } catch (urlError) {
                         logWarn(`解析 TS URL 失败: "${trimmedLine}" 相对于 "${base}"`, urlError);
                     }
                }
            }
            return urls;
        }

        async function preloadTsSegmentsWithCache(tsUrls) {
            if (tsUrls.length === 0) return;
            try {
                const cache = await caches.open(getCacheName());
                for (const tsUrl of tsUrls) {
                    try {
                        const cachedResponse = await cache.match(tsUrl);
                        if (!cachedResponse) {
                            const response = await fetch(tsUrl, { method: "GET", mode: 'cors' });
                            if (response.ok) {
                                // Must clone response to put in cache and potentially use later
                                await cache.put(tsUrl, response.clone());
                                log(`TS 已缓存: ${tsUrl}`);
                            } else {
                                logWarn(`TS 拉取失败 (${response.status}): ${tsUrl}`);
                            }
                        } else {
                            log(`TS 已在缓存中: ${tsUrl}`);
                        }
                    } catch (fetchCacheError) {
                        logError(`TS 缓存/获取失败: ${tsUrl}`, fetchCacheError);
                    }
                }
            } catch (cacheOpenError) {
                logError("无法打开 Cache Storage:", cacheOpenError);
                // Fallback to non-cache method? Or just fail gracefully?
                await preloadTsSegmentsWithoutCache(tsUrls); // Fallback
            }
        }

        async function preloadTsSegmentsWithoutCache(tsUrls) {
            log("使用 Fetch 进行预加载 (无 Cache API)");
            for (const tsUrl of tsUrls) {
                try {
                     // Just fetch, don't need the response body here
                    const response = await fetch(tsUrl, { method: "GET", mode: 'cors' });
                    if (response.ok) {
                        log(`TS 已拉取 (非缓存): ${tsUrl}`);
                        // We need to consume the body for the fetch to complete fully in some browsers
                        await response.arrayBuffer();
                    } else {
                        logWarn(`TS 拉取失败 (${response.status}) (非缓存): ${tsUrl}`);
                    }
                } catch (fetchError) {
                    logError(`TS 拉取异常 (非缓存): ${tsUrl}`, fetchError);
                }
            }
        }


        // --- Event Registration ---
        function safeRegisterPreloadEvents() {
             // Access state safely from main script
            const episodes = window.currentEpisodes;
            const currentIndex = window.currentEpisodeIndex;


            if (!isPreloadingEnabled()) return; // Don't register if disabled

             // Check if main script state is ready
            if (!Array.isArray(episodes) || typeof currentIndex !== 'number') {
                log("主脚本状态未就绪，稍后重试事件注册");
                setTimeout(safeRegisterPreloadEvents, 300); // Retry after a delay
                return;
            }

            log("注册预加载事件监听器");

            // Next Button Interaction
            const nextBtn = document.getElementById('nextButton'); // Use constant ID if available
            if (nextBtn && !nextBtn._preloadHooked) {
                nextBtn._preloadHooked = true; // Prevent multiple attachments
                const triggerPreload = () => setTimeout(preloadNextEpisodeParts, getConfigValue('preloadDelay'));
                nextBtn.addEventListener('mouseenter', triggerPreload, { passive: true });
                nextBtn.addEventListener('touchstart', triggerPreload, { passive: true });
                log("下一集按钮监听器已添加");
            }

            // Video Time Update Near End
            setupTimeupdatePreload();

            // Episode List Click (Event delegation is better, but this targets any click)
            const episodesList = document.getElementById('episodesList'); // Use constant ID
            if (episodesList && !episodesList._preloadHooked) {
                episodesList._preloadHooked = true;
                 // Listen on the container, trigger after a delay to allow state update
                episodesList.addEventListener('click', (e) => {
                    if (e.target.closest('button[id^="episode-"]')) {
                        log("剧集列表点击，延迟触发预加载");
                        setTimeout(preloadNextEpisodeParts, getConfigValue('preloadDelay'));
                    }
                });
                log("剧集列表点击监听器已添加");
            }
        }

        function setupTimeupdatePreload() {
             // Wait for DPlayer instance (dp) to be available on window or accessible scope
             let tries = 0;
             const maxTries = 50; // Limit retries
             const interval = 200; // Check every 200ms

             const checkPlayerInterval = setInterval(() => {
                 const playerInstance = window.dp; // Access DPlayer instance
                 tries++;

                 if (playerInstance && playerInstance.video && typeof playerInstance.video.addEventListener === 'function') {
                     if (!playerInstance._preloadTimeUpdateHooked) { // Ensure listener added only once per player instance
                         playerInstance._preloadTimeUpdateHooked = true;
                         const timeUpdateThreshold = getConfigValue('timeUpdateThreshold');

                         playerInstance.video.addEventListener('timeupdate', function() {
                            if (isPreloadingEnabled() && // Check if still enabled
                                playerInstance.video.duration &&
                                (playerInstance.video.duration - playerInstance.video.currentTime <= timeUpdateThreshold) &&
                                !playerInstance._preloadTriggeredByTime // Prevent rapid triggers
                            ) {
                                log(`时间接近结尾 (${playerInstance.video.currentTime.toFixed(1)}/${playerInstance.video.duration.toFixed(1)}s)，触发预加载`);
                                playerInstance._preloadTriggeredByTime = true;
                                preloadNextEpisodeParts();
                                // Reset trigger flag after a while, or on seek/episode change
                                setTimeout(() => { playerInstance._preloadTriggeredByTime = false; }, 5000); // Reset after 5s
                            }
                         });
                         log("播放时间更新预加载监听器已添加");
                     }
                     clearInterval(checkPlayerInterval); // Stop checking once setup
                 } else if (tries >= maxTries) {
                     logWarn("无法设置时间更新预加载监听器: DPlayer 实例未找到");
                     clearInterval(checkPlayerInterval); // Stop checking after max tries
                 }
             }, interval);
         }

        // --- Initial Trigger ---
        function triggerFirstPreload(tryCount = 0) {
             // Access state safely
            const episodes = window.currentEpisodes;
            const currentIndex = window.currentEpisodeIndex;

            if (isPreloadingEnabled() && Array.isArray(episodes) && typeof currentIndex === 'number') {
                log('首次自动预加载触发');
                preloadNextEpisodeParts();
            } else if (tryCount < getConfigValue('maxInitialRetries')) {
                 // Retry if main script might not be ready yet
                setTimeout(() => triggerFirstPreload(tryCount + 1), getConfigValue('initialPreloadDelay'));
            } else {
                 logWarn('首次自动预加载未触发 (状态未就绪)');
            }
        }

        // --- Global Wrapper for playEpisode ---
        // Ensure the original playEpisode (now playEpisodeInternal) exists before wrapping
        if (typeof window.playEpisodeInternal === 'function') {
            const originalPlayEpisode = window.playEpisodeInternal;
            // Expose the wrapped function globally if needed, or keep it internal
            window.playEpisode = function(index) {
                // Call the original function first
                originalPlayEpisode(index);
                // Trigger preload after a delay, allowing the state to update
                if (isPreloadingEnabled()) {
                    log(`playEpisode 调用 (索引 ${index})，延迟触发预加载`);
                    setTimeout(preloadNextEpisodeParts, getConfigValue('preloadDelay'));
                }
            };
             log("playEpisode 已包装以包含预加载触发");
        } else {
             logError("无法包装 playEpisode: window.playEpisodeInternal 未找到");
             // If playEpisode needs to be globally available, expose the internal one directly
             // window.playEpisode = window.playEpisodeInternal;
        }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            log("DOM 加载完成，初始化预加载逻辑");
            safeRegisterPreloadEvents();
            triggerFirstPreload();
        });

        // Expose preload function globally for potential manual trigger or debugging
         window.preloadNextEpisodeParts = preloadNextEpisodeParts;

    })();
    </script>

</body>
</html>
